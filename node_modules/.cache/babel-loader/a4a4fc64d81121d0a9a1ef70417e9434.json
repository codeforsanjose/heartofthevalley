{"ast":null,"code":"import { lerp } from './math-utils';\nimport { scaleToZoom, zoomToScale, lngLatToWorld, worldToLngLat } from './web-mercator-utils';\nimport * as vec2 from 'gl-matrix/vec2';\nconst EPSILON = 0.01;\nconst VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom'];\nconst DEFAULT_OPTS = {\n  curve: 1.414,\n  speed: 1.2\n};\nexport default function flyToViewport(startProps, endProps, t, options) {\n  const {\n    startZoom,\n    startCenterXY,\n    uDelta,\n    w0,\n    u1,\n    S,\n    rho,\n    rho2,\n    r0\n  } = getFlyToTransitionParams(startProps, endProps, options);\n\n  if (u1 < EPSILON) {\n    const viewport = {};\n\n    for (const key of VIEWPORT_TRANSITION_PROPS) {\n      const startValue = startProps[key];\n      const endValue = endProps[key];\n      viewport[key] = lerp(startValue, endValue, t);\n    }\n\n    return viewport;\n  }\n\n  const s = t * S;\n  const w = Math.cosh(r0) / Math.cosh(r0 + rho * s);\n  const u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;\n  const scaleIncrement = 1 / w;\n  const newZoom = startZoom + scaleToZoom(scaleIncrement);\n  const newCenterWorld = vec2.scale([], uDelta, u);\n  vec2.add(newCenterWorld, newCenterWorld, startCenterXY);\n  const newCenter = worldToLngLat(newCenterWorld);\n  return {\n    longitude: newCenter[0],\n    latitude: newCenter[1],\n    zoom: newZoom\n  };\n}\nexport function getFlyToDuration(startProps, endProps, options) {\n  const opts = { ...DEFAULT_OPTS,\n    ...options\n  };\n  const {\n    screenSpeed,\n    speed,\n    maxDuration\n  } = opts;\n  const {\n    S,\n    rho\n  } = getFlyToTransitionParams(startProps, endProps, opts);\n  const length = 1000 * S;\n  let duration;\n\n  if (Number.isFinite(screenSpeed)) {\n    duration = length / (screenSpeed / rho);\n  } else {\n    duration = length / speed;\n  }\n\n  return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;\n}\n\nfunction getFlyToTransitionParams(startProps, endProps, opts) {\n  opts = Object.assign({}, DEFAULT_OPTS, opts);\n  const rho = opts.curve;\n  const startZoom = startProps.zoom;\n  const startCenter = [startProps.longitude, startProps.latitude];\n  const startScale = zoomToScale(startZoom);\n  const endZoom = endProps.zoom;\n  const endCenter = [endProps.longitude, endProps.latitude];\n  const scale = zoomToScale(endZoom - startZoom);\n  const startCenterXY = lngLatToWorld(startCenter);\n  const endCenterXY = lngLatToWorld(endCenter);\n  const uDelta = vec2.sub([], endCenterXY, startCenterXY);\n  const w0 = Math.max(startProps.width, startProps.height);\n  const w1 = w0 / scale;\n  const u1 = vec2.length(uDelta) * startScale;\n\n  const _u1 = Math.max(u1, EPSILON);\n\n  const rho2 = rho * rho;\n  const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);\n  const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);\n  const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);\n  const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n  const S = (r1 - r0) / rho;\n  return {\n    startZoom,\n    startCenterXY,\n    uDelta,\n    w0,\n    u1,\n    S,\n    rho,\n    rho2,\n    r0,\n    r1\n  };\n}","map":{"version":3,"mappings":"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","names":["lerp","scaleToZoom","zoomToScale","lngLatToWorld","worldToLngLat","vec2","EPSILON","VIEWPORT_TRANSITION_PROPS","DEFAULT_OPTS","curve","speed","flyToViewport","startProps","endProps","t","options","startZoom","startCenterXY","uDelta","w0","u1","S","rho","rho2","r0","getFlyToTransitionParams","viewport","key","startValue","endValue","s","w","Math","cosh","u","tanh","sinh","scaleIncrement","newZoom","newCenterWorld","scale","add","newCenter","longitude","latitude","zoom","getFlyToDuration","opts","screenSpeed","maxDuration","length","duration","Number","isFinite","Object","assign","startCenter","startScale","endZoom","endCenter","endCenterXY","sub","max","width","height","w1","_u1","b0","b1","log","sqrt","r1"],"sources":["../../src/fly-to-viewport.ts"],"sourcesContent":["import {lerp} from './math-utils';\nimport {scaleToZoom, zoomToScale, lngLatToWorld, worldToLngLat} from './web-mercator-utils';\nimport * as vec2 from 'gl-matrix/vec2';\n\nimport type {ViewportProps} from './normalize-viewport-props';\n\nconst EPSILON = 0.01;\nconst VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom'] as const;\nconst DEFAULT_OPTS = {\n  curve: 1.414,\n  speed: 1.2\n  // screenSpeed and maxDuration are used only if specified\n};\n\nexport type FlytoTransitionOptions = {\n  curve?: number;\n  speed?: number;\n  screenSpeed?: number;\n  maxDuration?: number;\n};\n\n/**\n * mapbox-gl-js flyTo : https://www.mapbox.com/mapbox-gl-js/api/#map#flyto.\n * It implements “Smooth and efficient zooming and panning.” algorithm by\n * \"Jarke J. van Wijk and Wim A.A. Nuij\"\n */\nexport default function flyToViewport(\n  startProps: ViewportProps,\n  endProps: ViewportProps,\n  t: number,\n  options?: FlytoTransitionOptions\n): {\n  longitude: number;\n  latitude: number;\n  zoom: number;\n} {\n  // Equations from above paper are referred where needed.\n\n  const {startZoom, startCenterXY, uDelta, w0, u1, S, rho, rho2, r0} = getFlyToTransitionParams(\n    startProps,\n    endProps,\n    options\n  );\n\n  // If change in center is too small, do linear interpolaiton.\n  if (u1 < EPSILON) {\n    const viewport = {};\n    for (const key of VIEWPORT_TRANSITION_PROPS) {\n      const startValue = startProps[key];\n      const endValue = endProps[key];\n      viewport[key] = lerp(startValue, endValue, t);\n    }\n    // @ts-expect-error properties are populated dynamically\n    return viewport;\n  }\n\n  const s = t * S;\n\n  const w = Math.cosh(r0) / Math.cosh(r0 + rho * s);\n  const u = (w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2)) / u1;\n\n  const scaleIncrement = 1 / w; // Using w method for scaling.\n  const newZoom = startZoom + scaleToZoom(scaleIncrement);\n\n  const newCenterWorld = vec2.scale([], uDelta, u);\n  vec2.add(newCenterWorld, newCenterWorld, startCenterXY);\n\n  const newCenter = worldToLngLat(newCenterWorld);\n  return {\n    longitude: newCenter[0],\n    latitude: newCenter[1],\n    zoom: newZoom\n  };\n}\n\n// returns transition duration in milliseconds\nexport function getFlyToDuration(\n  startProps: ViewportProps,\n  endProps: ViewportProps,\n  options?: FlytoTransitionOptions\n): number {\n  const opts = {...DEFAULT_OPTS, ...options};\n  const {screenSpeed, speed, maxDuration} = opts;\n  const {S, rho} = getFlyToTransitionParams(startProps, endProps, opts);\n  const length = 1000 * S;\n  let duration: number;\n  if (Number.isFinite(screenSpeed)) {\n    duration = length / (screenSpeed / rho);\n  } else {\n    duration = length / speed;\n  }\n\n  return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;\n}\n\n// Private Methods\n\n// Calculate all parameters that are static for given startProps and endProps\nfunction getFlyToTransitionParams(\n  startProps: ViewportProps,\n  endProps: ViewportProps,\n  opts: FlytoTransitionOptions\n): {\n  startZoom: number;\n  startCenterXY: number[];\n  uDelta: number[];\n  w0: number;\n  u1: number;\n  S: number;\n  rho: number;\n  rho2: number;\n  r0: number;\n  r1: number;\n} {\n  opts = Object.assign({}, DEFAULT_OPTS, opts);\n  const rho = opts.curve;\n  const startZoom = startProps.zoom;\n  const startCenter = [startProps.longitude, startProps.latitude];\n  const startScale = zoomToScale(startZoom);\n  const endZoom = endProps.zoom;\n  const endCenter = [endProps.longitude, endProps.latitude];\n  const scale = zoomToScale(endZoom - startZoom);\n\n  const startCenterXY = lngLatToWorld(startCenter);\n  const endCenterXY = lngLatToWorld(endCenter);\n  const uDelta = vec2.sub([] as number[], endCenterXY, startCenterXY);\n\n  const w0 = Math.max(startProps.width, startProps.height);\n  const w1 = w0 / scale;\n  const u1 = vec2.length(uDelta) * startScale;\n  // u0 is treated as '0' in Eq (9).\n\n  // If u1 is too small, will generate invalid number\n  const _u1 = Math.max(u1, EPSILON);\n\n  // Implement Equation (9) from above algorithm.\n  const rho2 = rho * rho;\n  const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);\n  const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);\n  const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);\n  const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n  const S = (r1 - r0) / rho;\n\n  return {startZoom, startCenterXY, uDelta, w0, u1, S, rho, rho2, r0, r1};\n}\n"]},"metadata":{},"sourceType":"module"}